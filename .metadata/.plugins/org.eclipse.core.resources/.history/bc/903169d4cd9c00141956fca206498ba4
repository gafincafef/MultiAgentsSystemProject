package edu.rits.ma.algorithm.nashequil;

import java.util.ArrayList;
import java.util.List;

import edu.rits.ma.algorithm.theory.IPreference;
import edu.rits.ma.algorithm.theory.IPreferenceSet;
import edu.rits.ma.algorithm.theory.IUtilitiesMap;
import edu.rits.ma.algorithm.theory.NashEquilibriumProblem;
import edu.rits.ma.common.abstr.ITask;

public class FindBestPreferencesTaskImpl implements ITask {

	private int mPrimaryAgentId;
	private IPreference mSubPreference = null;
	private NashEquilibriumProblem mProblem = null;
	
	private List<IPreference> mCandidatePreferences = new ArrayList<IPreference>();
	
	public FindBestPreferencesTaskImpl(int primaryAgentId, IPreference subPreference, NashEquilibriumProblem problem) {
		mPrimaryAgentId = primaryAgentId;
		mSubPreference = subPreference;
		mProblem = problem;
	}
	
	@Override
	public long getTimeOutMs() {
		return 1000;
	}

	@Override
	public void execute() {
		List<IPreference> subPreferenceContainers = new ArrayList<IPreference>();
		IPreferenceSet preferenceSet = mProblem.getPreferenceSet();
		preferenceSet.getPreferencesContains(mSubPreference, subPreferenceContainers);
		
		findBestPrefenrencesForPrimaryAgent(subPreferenceContainers, mCandidatePreferences);
	}

	@Override
	public int getStatus() {
		return 0;
	}

	@Override
	public Object[] getResults() {
		return mCandidatePreferences.toArray();
	}

	@Override
	public void createSubTasks(List<ITask> subTasks) {
		
	}
	
	//TODO Consider moving this work to utilities map
	private void findBestPrefenrencesForPrimaryAgent(List<IPreference> preferences, List<IPreference> outputs) {
		int bestUtilities = Integer.MIN_VALUE;
		IUtilitiesMap utilityMap = mProblem.getUtilitiesMap();
		for(IPreference preference : preferences) {
			int utility = utilityMap.getUtilityOfAgent(preference, mPrimaryAgentId);
		}
	}

}
