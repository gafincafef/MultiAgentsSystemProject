package edu.rits.ma.jade.taskprocessor;

import jade.lang.acl.ACLMessage;

import java.util.ArrayList;
import java.util.List;

import edu.rits.ma.common.abstr.ITask;
import edu.rits.ma.jade.communication.ContentElementIncomingBuffer;
import edu.rits.ma.jade.communication.ContentElementOutcomingBuffer;
import edu.rits.ma.jade.communication.ContentElementWrapper;

public class PrimaryOntologyBufferProcessorImpl implements IOntologyBufferProcessor {

	private static final int ACTION_PHASE_TO_WAIT_SECONDARY_AGENTS_READY = 0;
	private static final int ACTION_PHASE_TO_PROCESS_READY_MESSAGE = 1;
	private static final int ACTION_PHASE_TO_WAIT_SECONDARY_AGENTS_DONE_TASK = 3;
	private static final int ACTION_PHASE_TO_PROCESS_TASK_DONE_MESSAGE = 4;
	private static final int ACTION_PHASE_TO_STOP = 5;

	private int mInternalState = ACTION_PHASE_TO_WAIT_SECONDARY_AGENTS_READY;
	private List<ITask> mTasks = null;
	private List<String> mSecondaryAgentNames = null;

	private TaskExecutingStatus mExecutingStatus = null;

	public PrimaryOntologyBufferProcessorImpl(List<ITask> tasks, List<String> secondaryAgentNames) {
		mTasks = tasks;
		mSecondaryAgentNames = secondaryAgentNames;
		mExecutingStatus.setNumberOfSecondaryAgentsNotReady(secondaryAgentNames.size());
		mExecutingStatus = new TaskExecutingStatus(mTasks.size());
	}
	
	@Override
	public void processCommunicationDataStore(ContentElementIncomingBuffer receiveBuffer, ContentElementOutcomingBuffer sendBuffer) {
		updateInternalState(receiveBuffer);
		try {
			int nextActionPhase = mInternalState;
			switch (mInternalState) {
			case ACTION_PHASE_TO_PROCESS_READY_MESSAGE:
				nextActionPhase = onReadyMessage(sendBuffer);
				break;
			case ACTION_PHASE_TO_PROCESS_TASK_DONE_MESSAGE:
				nextActionPhase = onTaskDoneMessage(receiveBuffer, sendBuffer);
				break;
			default:
				break;
			}
			mInternalState = nextActionPhase;
		} catch (Exception e) {
			e.printStackTrace();
			mInternalState = ACTION_PHASE_TO_STOP;
		}
	}
	
	@Override
	public boolean done() {
		return mInternalState == ACTION_PHASE_TO_STOP;
	}

	private void updateInternalState(ContentElementIncomingBuffer receiveBuffer) {
		if(receiveBuffer.hasReceivedData()) {
			ContentElementWrapper contentElement = receiveBuffer.extractRetrievedContentElement();
			mInternalState = detectStateByReceivedMessage(message); 
		}
	}

	private int onReadyMessage(ContentElementOutcomingBuffer sendBuffer) {
		mExecutingStatus.decrementNumberOfSecondaryAgentsNotReady();
		if(mExecutingStatus.allSecondaryAgentReady()) {
			runNextTask(sendBuffer);
			return ACTION_PHASE_TO_WAIT_SECONDARY_AGENTS_DONE_TASK;
		}
		return ACTION_PHASE_TO_WAIT_SECONDARY_AGENTS_READY;
	}

	private int onTaskDoneMessage(ContentElementIncomingBuffer receiveBuffer, ContentElementOutcomingBuffer sendBuffer) {
		//receiveBuffer.extractReceivedMessage();
		mExecutingStatus.decrementNumberOfSubTasksToWait();
		
		if(mExecutingStatus.allSubTasksDone()) {
			return onAllSubTaskDone(sendBuffer);
		}
		return ACTION_PHASE_TO_WAIT_SECONDARY_AGENTS_DONE_TASK;
	}
	
	private int onAllSubTaskDone(ContentElementOutcomingBuffer sendBuffer) {
		if(mExecutingStatus.allTasksDone()) {
			return onAllTasksDone(sendBuffer);
		}
		else {
			runNextTask(sendBuffer);
		}
		return ACTION_PHASE_TO_WAIT_SECONDARY_AGENTS_DONE_TASK;
	}

	private int onAllTasksDone(ContentElementOutcomingBuffer sendBuffer) {
		stopSecondaryAgents(sendBuffer);
		return ACTION_PHASE_TO_STOP;
	}
	
	private void runNextTask(ContentElementOutcomingBuffer sendBuffer) {
		ITask nextTask = mTasks.get(mExecutingStatus.getNextTaskId());
		int numberOfSubTasksToWait = runNextTask(nextTask, sendBuffer);
		mExecutingStatus.incrementNextTaskId();
		mExecutingStatus.setNumberOfSubTasksToWait(numberOfSubTasksToWait);
	}
	
	private int runNextTask(ITask task, ContentElementOutcomingBuffer sendBuffer) {
		int newSecondaryTasks = 0;
		
		//Firstly execute the task assigned to primary agent
		task.execute();

		if(task.getStatus() == ITask.TASK_STATUS_SUCCEEDED) {
			List<ITask> subTasks = new ArrayList<ITask>();

			//Each task spawns a list of sub task after finished
			task.createSubTasks(subTasks);

			for(int i = 0; i < subTasks.size(); i++) {
				int secondaryAgentIndex = i; 
				newSecondaryTasks++;

				//Add task object to secondary agents by adding task to queue
				assignTaskToSecondaryAgent(sendBuffer, mSecondaryAgentNames.get(secondaryAgentIndex), subTasks.get(i));
			}
		}
		
		return newSecondaryTasks;
	}

	private void assignTaskToSecondaryAgent(ContentElementOutcomingBuffer sendBuffer, String secondaryAgentName, ITask task) {
		/*InProcessObjectMessage objectMessage = new InProcessObjectMessage();
		objectMessage.setObject(task);
		objectMessage.setTargetAgentName(secondaryAgentName);
		sendBuffer.addObjectToSend(objectMessage);*/
		//TODO Implement
	}
	
	private void stopSecondaryAgents(ContentElementOutcomingBuffer sendBuffer) {
		/*ACLMessage message = new ACLMessage(ACLMessage.INFORM);
		for(String secondaryAgentName : mSecondaryAgentNames) {
			message.addReceiver(new AID(secondaryAgentName, AID.ISGUID));
		}
		message.setContent("Stop");
		sendBuffer.addMessageToSend(message);*/
		
		//TODO Implement
	}

	private int detectStateByReceivedMessage(ACLMessage message) {
		//TODO Implement using ontology
		if(message.getContent().equals("Ready")) {
			return ACTION_PHASE_TO_PROCESS_READY_MESSAGE;
		}
		return ACTION_PHASE_TO_PROCESS_TASK_DONE_MESSAGE;
	}

}
